type Scope {
  id: ID!
}

type Persona {
  scope : Scope!
}

type Segment {
  scope: Scope!
}

type List {
  scope: Scope!
}

type Interest {
  scope : Scope!
}

interface Profile {
  id: ID!
  properties : [KeyValue]
}

// Browser --(structured event)--> Client -> ClientProfile -> MasterProfile

type ClientProfile implements Profile {
  id: ID!
  properties : [KeyValue] // defined in the CXS server configuration
  client : Client
  masterProfile : MasterProfile
  schema: SchemaCompoundType
}

type PropertyValue {
  key: String!
  value: String
  clients : [Client]
}

type MasterProfile implements Profile {
  id: ID!
  properties : [PropertyValue] // defined in the CXS server configuration
  clientProfiles : [ClientProfile]
  privacy : Privacy
  schema: SchemaCompoundType
}

type Privacy {
  doNotTrack: Boolean
  anonymousBrowsing : Boolean
  propertiesPolicy : [PropertyPolicy]
}

type PropertyPolicy {
  propertyKey : String!
  policyName : String!
}

type PropertyPermission {
  permission : String!
  applicationKey : ApplicationKey
}

type Query {
  conditions : [Condition]
}

type Condition {
}

interface PropertyDefinition {
  name : String!
  description : String
  type : String
  identifier : Boolean
}

type EventPropertyDefinition {
  name : String!
  description : String
  type : String
  identifier : Boolean
}

type MasterPropertyDefinition {
  name : String!
  description : String
  type : String
  identifier : Boolean
}

type ApplicationKey {
  client: Client!
  label : String!
  key: ID!
  permissions: [String] // "createEvent", "createEventTypes", "fullAccess"
}

type Client {
  applicationKeys: [ApplicationKey]
  description: String!
  name: String!
  thirdPartySystem : Boolean
}

type PropertyValue {
  key: String!
  value: String
  client : Client!
}

type KeyValue {
  key: String!
  value : String
}

type Event {
  id: ID!
  type: [EventType]!
  client: Client!
  subject: ClientProfile!
  object: String!
  location: [GeoPoint]
  timestamp: DateTime
  properties: [KeyValue]
}

// schema definition 
// the union is used to make it possible to define recursive type structures
union SchemaType = SchemaScalarType | SchemaCompoundType

type SchemaScalarType {
  name : String!
  description : String
  type : String // scalar type
  identifier : Boolean
  aliases : [String] // email, e-mail, mail, m√©l, couriel
}

type SchemaCompoundType {
  name : String!
  description : String
  types : [SchemaType]
}

// event types are defined using schema types, see event-analysis.md for examples

type EventType {
  id: ID! // human-readable, unique, ex: org.oasis-open.cxs.webClient.PageView,org.acmeCrm.cxs.crmClient.ColdCall
  description: String
  schema : SchemaCompoundType
}

enum SortOrder {
  ASC,
  DESC,
  UNSPECIFIED
}

type EventFilter {
  type : [String]!
  length : Int
  sortProperty : String
  sortOrder : SortOrder
}

type Context {
  profile : ClientProfile
  session : Session
  filterResults : [FilterResult]
  events(filter : EventFilter) : [Event]
}

type Filter {
  name : String!
  query : BooleanQuery
}

type FilterResult {
  name : String!
  result : Boolean
}

// QUERY TYPES

type Query {
  event(id : String) : Event
  context(filters : [Filter], profileId: String) : Context
}

// sample usage of these query types

query eventById($id: ID!) {
  event(id: $id) {
    type
  }
}

query completeContext($filters : [Filter], $sessionId : String) {
  context(filters : $filters, sessionId : $sessionId) {
    profile
    session
    filterResults
  }
}

query smallContext($filters : [Filter], $sessionId : String) {
  context(filters : $filters, sessionId : $sessionId) {
    profile
  }
}

query emailAndProductsViewsContext($clientProfileId : String, $eventFilter : EventFilter) {
  context(clientProfileId : $clientProfileId) {
    events(filter : $eventFilter) {
      timeStamp
      object
      properties(filter: ["productName", "productSKU", "productDescription"]) {
        key
        value
      }
    }
    profile {
      properties(filter : "email") {
        value
      }
    }
  }
}

// MUTATION TYPES

type Mutation {
  createEvent(applicationKey: ApplicationKey!, type: EventType!, timeStamp : DateTime, location: GeoPoint, properties : [KeyValue]) : Event
  getContext(events: [Event], filters : [Filter], sessionId: String) : Context
}

// Sample usage of the above mutation type

mutation minimalCreateEvent($applicationKey: ApplicationKey!, $eventType: EventType!, $timeStamp: Date, $location: GeoPoint, $data: [KeyValue] ) {
  createEvent(applicationKey: $applicationKey, type: $eventType, timeStamp : $timeStamp, location: $location, properties : $data) {
  }
}

mutation detailedCreateEvent($applicationKey: ApplicationKey!, $eventType: EventType!, $timeStamp: Date, $location: GeoPoint, $data: [KeyValue] ) {
  createEvent(applicationKey: $applicationKey, type: $eventType, timeStamp : $timeStamp, location: $location, properties : $data) {
    id
    type
    client
    subject
    object
    properties
  }
}

mutation collectEvent($applicationKey: ApplicationKey!, $event : [Event]) {
  collectEvent(applicationKey: $applicationKey, event: $event) {
  }
}

mutation getContext($events: [Event], $queries: [Query], $sessionId : String!) {
  getContext(events: $events, queries: $Query, sessionId: $sessionId) {
    profile
    session
  }
}
