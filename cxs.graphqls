type Scope {
  id: ID!
}

type Persona {
  scope : Scope!
}

type Segment {
  scope: Scope!
}

type List {
  scope: Scope!
}

type Interest {
  scope : Scope!
}

interface Profile {
  id: ID!
  properties : [KeyValue]
}

type ClientProfile implements Profile {
  id: ID!
  properties : [KeyValue] // defined in the CXS server configuration
  client : Client
  masterProfile : MasterProfile
}

type MasterProfile implements Profile {
  id: ID!
  properties : [KeyValue] // defined in the CXS server configuration
  clientProfiles : [ClientProfile]
  privacy : Privacy
}

type Privacy {
  doNotTrack: Boolean
  anonymousBrowsing : Boolean
  propertiesPolicy : [PropertyPolicy]
}

type PropertyPolicy {
  propertyKey : String!
  policyName : String!
}

type PropertyPermission {
  permission : String!
  applicationKey : ApplicationKey
}

type Context {
  id: ID!
  segments : [Segment]
}

type Query {
  conditions : [Condition]
}

type Condition {
}

interface PropertyDefinition {
  name : String!
  description : String
  type : String
  identifier : Boolean
}

type EventPropertyDefinition {
  name : String!
  description : String
  type : String
  identifier : Boolean
}

type MasterPropertyDefinition {
  name : String!
  description : String
  type : String
  identifier : Boolean
}

type ApplicationKey {
  client: Client!
  label : String!
  key: ID!
  permissions: [String] // "createEvent", "createEventTypes", "fullAccess"
}

type Client {
  applicationKeys: [ApplicationKey]
  description: String!
  name: String!
  thirdPartySystem : Boolean
}

type PropertyValue {
  key: String!
  value: String
  client : Client!
}

type KeyValue {
  key: String!
  value : String
}

type Event {
  id: ID!
  type: [EventType]!
  client: Client!
  subject: ClientProfile!
  object: String!
  location: [GeoPoint]
  timestamp: DateTime
  properties: [KeyValue]
}

// schema definition 
// the union is used to make it possible to define recursive type structures
union SchemaType = SchemaScalarType | SchemaCompoundType

type SchemaScalarType {
  name : String!
  description : String
  type : String // scalar type
  identifier : Boolean
}

type SchemaCompoundType {
  name : String!
  description : String
  types : [SchemaType]
}

// event types are defined using schema types, see event-analysis.md for examples

type EventType {
  id: ID! // human-readable, unique, ex: org.oasis-open.cxs.webClient.PageView,org.acmeCrm.cxs.crmClient.ColdCall
  description: String
  schema : SchemaCompoundType
}

query EventById($id: ID!) {
  event(id: $id) {
    type
  }
}

query Events($id: ID!) {
  event(id: $id) {
    type
  }
}

mutation createEvent($applicationKey: ApplicationKey!, $eventType: EventType!, $timeStamp: Date, $location: GeoPoint, $data: Something ) {
  createEvent(applicationKey: $applicationKey, type: $eventType) {
    location
    timestamp
    key
    value
  }
}

mutation collectEvent($applicationKey: ApplicationKey!, $event : [Event]) {
  collectEvent(applicationKey: $applicationKey, event: $event) {
  }
}

mutation getContext($events: [Event], $queries: [Query], $sessionId : String!) {
  getContext(events: $events, queries: $Query, sessionId: $sessionId) {
    
  }
}
