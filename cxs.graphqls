type Scope {
  id: ID!
}

type Persona {
  scope : Scope!
}

type Segment {
  scope: Scope!
  name : ID! // this can be generated from displayname, but never changed
  displayName : String
  conditions: [Condition]  
}

type List {
  scope: Scope!
}

type Interest {
  scope : Scope!
  id: ID! // cannot change
  displayName : String
}

type InterestScore {
  interest: Interest!
  score : Float // 0.0 to 1.0
}

// session are event attributes, spanning across clients and client profiles
type Session {
  clientProfiles : [ClientProfile]
  events : [Event]
  properties : [KeyValue]
  startTime : Long
  endTime : Long
}

interface Profile {
  id: ID!
  properties : [KeyValue]
}

// Browser --(structured event)--> Client -> ClientProfile -> MasterProfile

type ClientProfile implements Profile {
  id: ID!
  properties : [KeyValue] // defined in the CXS server configuration
  client : Client
  masterProfile : MasterProfile
  schema: SchemaCompoundType
}

type PropertyValue {
  key: String!
  value: String
  clients : [Client]
}

type MasterProfile implements Profile {
  id: ID!
  properties : [PropertyValue] // defined in the CXS server configuration
  clientProfiles : [ClientProfile]
  privacy : Privacy
  schema: SchemaCompoundType
}

type Privacy {
  doNotTrack: Boolean
  anonymousBrowsing : Boolean
  propertiesPolicy : [PropertyPolicy]
}

type PropertyPolicy {
  propertyKey : String!
  policyName : String!
}

type PropertyPermission {
  permission : String!
  applicationKey : ApplicationKey
}

type ContextQuery {
  conditions : [Condition]
}

type Condition {
}

interface PropertyDefinition {
  name : String!
  description : String
  type : String
  identifier : Boolean
}

type EventPropertyDefinition {
  name : String!
  description : String
  type : String
  identifier : Boolean
}

type MasterPropertyDefinition {
  name : String!
  description : String
  type : String
  identifier : Boolean
}

type ApplicationKey {
  client: Client!
  label : String!
  key: ID!
  permissions: [String] // "createEvent", "createEventTypes", "fullAccess"
}

type Client {
  applicationKeys: [ApplicationKey]
  description: String!
  name: String!
  thirdPartySystem : Boolean
}

type PropertyValue {
  key: String!
  value: String
  client : Client!
}

type KeyValue {
  key: String!
  value : String
}

type Event {
  id: ID!
  type: [EventType]!
  client: Client!
  subject: ClientProfile!
  object: String!
  location: [GeoPoint]
  timestamp: DateTime
  properties: [KeyValue]
}

// schema definition 
// the union is used to make it possible to define recursive type structures
union SchemaType = SchemaScalarType | SchemaCompoundType

type SchemaScalarType {
  name : String!
  description : String
  type : String // scalar type
  identifier : Boolean
  aliases : [String] // email, e-mail, mail, m√©l, couriel
}

type SchemaCompoundType {
  name : String!
  description : String
  types : [SchemaType]
}

// event types are defined using schema types, see event-analysis.md for examples

type EventType {
  id: ID! // human-readable, unique, ex: org.oasis-open.cxs.webClient.PageView,org.acmeCrm.cxs.crmClient.ColdCall
  description: String
  schema : SchemaCompoundType
}

enum SortOrder {
  ASC,
  DESC,
  UNSPECIFIED
}

type EventFilter {
  type : [String]!
  length : Int
  sortProperty : String
  sortOrder : SortOrder
}

type Context {
  profile : ClientProfile
  session : Session
  events(filter : EventFilter) : [Event]
  segments : [Segment]
  dynamicSegments : [DynamicSegmentMatch]
  interests : [InterestScore]
}

type DynamicSegment {
  name : String!
  condition: Condition
}

type DynamicSegmentMatch {
  name : String
  matched : Boolean
  executionTimeMillis : Long
}

// QUERY TYPES

type Query {
  event(id : String) : Event
  context(dynamicSegments : [DynamicSegment], clientProfileId: String) : Context
  count(condition : Condition) : Long // used to count profiles matching a condition
}

// sample usage of these query types

query eventById($id: ID!) {
  event(id: $id) {
    type
  }
}

query completeContext($dynamicSegments : [DynamicSegment], $clientProfileId : String) {
  context(dynamicSegments : $dynamicSegments, clientProfileId : $clientProfileId) {
    profile {
      properties(filter: []) {
      }
    }
    session {
      properties(filter: []) {
      }
    }
    segments {
      name
    }
    dynamicSegments {
      name
      matched
      executionTimeMillis
    }
    interests {
      interest {
        id
        displayName
      }
      score
    }
  }
}

query smallContext($dynamicSegments : [DynamicSegment], $clientProfileId : String) {
  context(dynamicSegments : $dynamicSegments, clientProfileId : $clientProfileId) {
    profile {
      properties(filter : ["email"]) {
        value 
      }      
    }
  }
}

query allSegmentsContext($clientProfileId : String) {
  context(clientProfileId : $clientProfileId) {
    segments {
      name
    }
  }
}

query contextAllSegmentsIncludingDynamic($dynamicSegments : [DynamicSegment], $clientProfileId : String) {
  context(clientProfileId : $clientProfileId) {
    segments {
      name
    }
    dynamicSegments {
      name
      matched
    }
  }
}

// retrieve profile email and last products viewed
query emailAndProductsViewsContext($clientProfileId : String, $eventFilter : EventFilter) {
  context(clientProfileId : $clientProfileId) {
    events(filter : $eventFilter) {
      timeStamp
      object
      properties(filter: ["productName", "productSKU", "productDescription"]) {
        key
        value
      }
    }
    profile {
      properties(filter : "email") {
        value
      }
    }
  }
}

// MUTATION TYPES

type Mutation {
  createEvent(applicationKey: ApplicationKey!, type: EventType!, timeStamp : DateTime, location: GeoPoint, properties : [KeyValue]) : Event
  getContext(events: [Event], dynamicSegments : [DynamicSegment], clientProfileId: String!) : Context
}

// Sample usage of the above mutation type

mutation minimalCreateEvent($applicationKey: ApplicationKey!, $eventType: EventType!, $timeStamp: Date, $location: GeoPoint, $data: [KeyValue] ) {
  createEvent(applicationKey: $applicationKey, type: $eventType, timeStamp : $timeStamp, location: $location, properties : $data) {
  }
}

mutation detailedCreateEvent($applicationKey: ApplicationKey!, $eventType: EventType!, $timeStamp: Date, $location: GeoPoint, $data: [KeyValue] ) {
  createEvent(applicationKey: $applicationKey, type: $eventType, timeStamp : $timeStamp, location: $location, properties : $data) {
    id
    type
    client
    subject
    object
    properties
  }
}

mutation collectEvent($applicationKey: ApplicationKey!, $event : [Event]) {
  collectEvent(applicationKey: $applicationKey, event: $event) {
  }
}

mutation getContext($events: [Event], $dynamicSegments : [DynamicSegment], $clientProfileId : String!) {
  getContext(events: $events, dynamicSegments: $dynamicSegments, clientProfileId: $clientProfileId) {
    profile
    session
  }
}
